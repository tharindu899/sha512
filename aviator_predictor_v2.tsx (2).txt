import React, { useState, useEffect, useRef } from 'react';
import { Hash, TrendingUp, Clock, Target, AlertCircle, Check, Copy, Trash2, Bell, Settings, ChevronRight } from 'lucide-react';

const AviatorPredictor = () => {
  const [hash, setHash] = useState('');
  const [predictions, setPredictions] = useState({});
  const [selectedOdd, setSelectedOdd] = useState(null);
  const [result, setResult] = useState(null);
  const [countdown, setCountdown] = useState(null);
  const [history, setHistory] = useState([]);
  const [activeTab, setActiveTab] = useState('predictor');
  const [showSignal, setShowSignal] = useState(false);
  const [signalData, setSignalData] = useState(null);
  const countdownRef = useRef(null);

  // Enhanced entropy calculation
  const calcEntropy = (hashStr) => {
    const freq = {};
    for (let c of hashStr) freq[c] = (freq[c] || 0) + 1;
    return Object.values(freq).reduce((acc, f) => {
      const p = f / hashStr.length;
      return acc - p * Math.log2(p);
    }, 0);
  };

  // Advanced pattern detection
  const detectPatterns = (hashStr) => ({
    tripleRepeat: /(\w)\1{2,}/.test(hashStr),
    doubleRepeat: /(\w{2,4})\1{1,}/.test(hashStr),
    sequential: /(?:0123|1234|2345|3456|4567|5678|6789|789a|89ab|9abc|abcd|bcde|cdef)/.test(hashStr),
    tailPattern: /^(aaaa|ffff|0000|1111|2222|3333|4444|5555|6666|7777|8888|9999)$/.test(hashStr.slice(-4))
  });

  // Enhanced scoring
  const scoreFromHash = (hashStr) => {
    const primary = [5, 15, 25, 35, 50, 75, 100, 120];
    const secondary = [10, 20, 40, 60, 80, 110];
    const primaryScore = primary.reduce((sum, i) => sum + parseInt(hashStr[i], 16), 0);
    const secondaryScore = secondary.reduce((sum, i) => sum + parseInt(hashStr[i], 16), 0);
    return Math.round(primaryScore * 0.7 + secondaryScore * 0.3);
  };

  // Calculate confidence with enhanced logic
  const calculateConfidence = (entropy, score, odd, hashStr) => {
    const patterns = detectPatterns(hashStr);
    let confidence = 50;

    // Entropy scoring
    if (entropy > 4.5) confidence += 20;
    else if (entropy > 4.2) confidence += 12;
    else if (entropy > 3.9) confidence += 8;

    // Score patterns
    if (score % 11 === 0) confidence += 12;
    if (score % 7 === 0) confidence += 8;
    if (score % 5 === 0) confidence += 5;

    // Pattern bonuses
    if (patterns.tripleRepeat) confidence += 15;
    if (patterns.doubleRepeat) confidence += 10;
    if (patterns.sequential) confidence += 8;
    if (patterns.tailPattern) confidence += 18;

    // Odd-specific adjustments
    const oddAdjustments = {
      2: { base: 8, entropyRange: [4.0, 4.3], scoreRange: [30, 60], bonus: 7 },
      3: { base: 7, entropyRange: [4.1, 4.4], scoreRange: [40, 70], bonus: 8 },
      4: { base: 5, entropyRange: [3.91, 3.97], scoreRange: [45, 80], bonus: 12 },
      7: { base: 6, entropyRange: [4.1, 4.4], scoreRange: [55, 90], bonus: 15 },
      10: { base: 12, entropyRange: [4.25, 4.5], scoreRange: [60, 100], bonus: 18 },
      100: { base: 15, entropyRange: [4.4, 5.0], scoreRange: [80, 120], bonus: 20 }
    };

    const adj = oddAdjustments[odd];
    if (adj) {
      confidence += adj.base;
      if (entropy >= adj.entropyRange[0] && entropy <= adj.entropyRange[1]) confidence += adj.bonus;
      if (score >= adj.scoreRange[0] && score <= adj.scoreRange[1]) confidence += Math.floor(adj.bonus * 0.7);
    }

    return Math.min(98, Math.max(15, Math.round(confidence)));
  };

  // Calculate delay
  const calculateDelay = (score, entropy, odd) => {
    let base = odd * 45;
    if (entropy > 4.5) base += 30;
    else if (entropy > 4.3) base += 20;
    if (score % 11 === 0) base += 35;
    if (score % 7 === 0) base += 30;
    
    const oddDelays = { 2: 10, 3: 10, 4: 20, 7: 35, 10: 75, 100: 650 };
    base += oddDelays[odd] || 0;
    
    return Math.max(odd * 40, base);
  };

  // Validate hash
  const validateHash = (hashStr) => {
    return hashStr.length === 128 && /^[a-f0-9]+$/.test(hashStr);
  };

  // Analyze hash when input changes
  useEffect(() => {
    if (!validateHash(hash)) {
      setPredictions({});
      return;
    }

    const entropy = calcEntropy(hash);
    const score = scoreFromHash(hash);
    const newPredictions = {};

    [2, 3, 4, 7, 10, 100].forEach(odd => {
      const confidence = calculateConfidence(entropy, score, odd, hash);
      const delay = calculateDelay(score, entropy, odd);
      newPredictions[odd] = { confidence, delay, entropy, score };
    });

    setPredictions(newPredictions);
  }, [hash]);

  // Handle prediction
  const predict = (odd) => {
    if (!validateHash(hash)) return;

    const prediction = predictions[odd];
    if (!prediction) return;

    const targetTime = new Date(Date.now() + prediction.delay * 1000);
    setSelectedOdd(odd);
    setResult({
      odd,
      ...prediction,
      targetTime: targetTime.toLocaleTimeString()
    });

    // Add to history
    const historyEntry = {
      id: Date.now(),
      odd,
      time: new Date().toLocaleTimeString(),
      targetTime: targetTime.toLocaleTimeString(),
      confidence: prediction.confidence,
      targetTimestamp: targetTime.getTime()
    };
    setHistory(prev => [historyEntry, ...prev].slice(0, 20));

    // Start countdown
    startCountdown(targetTime, odd);

    // Show signal popup 20s before
    const signalDelay = Math.max(0, prediction.delay - 20);
    setTimeout(() => {
      setSignalData({ odd, targetTime: targetTime.toLocaleTimeString() });
      setShowSignal(true);
    }, signalDelay * 1000);
  };

  // Countdown logic
  const startCountdown = (targetTime, odd) => {
    if (countdownRef.current) clearInterval(countdownRef.current);

    countdownRef.current = setInterval(() => {
      const now = Date.now();
      const diff = Math.floor((targetTime - now) / 1000);

      if (diff <= 0) {
        clearInterval(countdownRef.current);
        setCountdown({ text: `${odd}x Signal Active! Place bet now!`, type: 'active' });
      } else {
        const min = Math.floor(diff / 60);
        const sec = diff % 60;
        setCountdown({ 
          text: `Next ${odd}x signal in: ${min}m ${sec}s`,
          type: diff < 30 ? 'urgent' : diff < 60 ? 'warning' : 'normal'
        });
      }
    }, 1000);
  };

  // Auto-select best multiplier
  const autoSelect = () => {
    if (!validateHash(hash)) return;

    const recommendations = Object.entries(predictions).map(([odd, pred]) => {
      const safetyScore = 100 - (parseInt(odd) * 0.8);
      const riskAdjusted = safetyScore * 0.4 + pred.confidence * 0.6;
      return { odd: parseInt(odd), ...pred, safetyScore, riskAdjusted };
    });

    recommendations.sort((a, b) => b.riskAdjusted - a.riskAdjusted);
    if (recommendations[0]) predict(recommendations[0].odd);
  };

  // Copy result
  const copyResult = () => {
    if (!result) return;
    const text = `Aviator Signal\nOdd: ${result.odd}x\nTime: ${result.targetTime}\nConfidence: ${result.confidence}%`;
    navigator.clipboard.writeText(text);
  };

  // Paste hash
  const pasteHash = async () => {
    try {
      const text = await navigator.clipboard.readText();
      setHash(text.trim().toLowerCase());
    } catch (err) {
      console.error('Paste failed:', err);
    }
  };

  const oddColors = {
    2: 'bg-green-500',
    3: 'bg-yellow-500',
    4: 'bg-orange-500',
    7: 'bg-purple-500',
    10: 'bg-red-500',
    100: 'bg-pink-500'
  };

  const oddLabels = {
    2: 'Safe',
    3: 'Balanced',
    4: 'Moderate',
    7: 'High Risk',
    10: 'Very High',
    100: 'Extreme'
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
      {/* Header */}
      <div className="bg-gradient-to-r from-blue-600 to-purple-600 p-4 shadow-lg">
        <div className="flex items-center justify-between max-w-6xl mx-auto">
          <div className="flex items-center gap-2">
            <Hash className="w-6 h-6" />
            <h1 className="text-xl font-bold">Aviator SHA512 Predictor</h1>
          </div>
          <div className="text-sm opacity-90">{new Date().toLocaleTimeString()}</div>
        </div>
      </div>

      {/* Navigation */}
      <div className="border-b border-slate-700">
        <div className="max-w-6xl mx-auto flex">
          {['predictor', 'history'].map(tab => (
            <button
              key={tab}
              onClick={() => setActiveTab(tab)}
              className={`px-6 py-3 capitalize font-medium transition-colors ${
                activeTab === tab
                  ? 'bg-slate-800 text-blue-400 border-b-2 border-blue-400'
                  : 'text-slate-400 hover:text-white'
              }`}
            >
              {tab}
            </button>
          ))}
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-6xl mx-auto p-4">
        {activeTab === 'predictor' && (
          <div className="space-y-6">
            {/* Hash Input */}
            <div className="bg-slate-800 rounded-lg p-6 shadow-xl">
              <label className="block text-sm font-medium text-slate-300 mb-2">
                SHA512 Hash (128 hex characters)
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={hash}
                  onChange={(e) => setHash(e.target.value.trim().toLowerCase())}
                  placeholder="Enter or paste hash..."
                  className="flex-1 px-4 py-3 bg-slate-900 border border-slate-700 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
                <button
                  onClick={pasteHash}
                  className="px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors"
                >
                  <Copy className="w-5 h-5" />
                </button>
                <button
                  onClick={() => setHash('')}
                  className="px-4 py-3 bg-red-600 hover:bg-red-700 rounded-lg transition-colors"
                >
                  <Trash2 className="w-5 h-5" />
                </button>
              </div>
              {hash && !validateHash(hash) && (
                <p className="text-red-400 text-sm mt-2">Invalid hash format</p>
              )}
            </div>

            {/* Auto Select */}
            {validateHash(hash) && (
              <button
                onClick={autoSelect}
                className="w-full py-4 bg-gradient-to-r from-green-600 to-blue-600 hover:from-green-700 hover:to-blue-700 rounded-lg font-semibold flex items-center justify-center gap-2 transition-all transform hover:scale-105"
              >
                <TrendingUp className="w-5 h-5" />
                Auto-Select Best Multiplier
              </button>
            )}

            {/* Multiplier Buttons */}
            {validateHash(hash) && (
              <div className="grid grid-cols-3 md:grid-cols-6 gap-4">
                {[2, 3, 4, 7, 10, 100].map(odd => {
                  const pred = predictions[odd];
                  return (
                    <button
                      key={odd}
                      onClick={() => predict(odd)}
                      className={`relative bg-slate-800 hover:bg-slate-700 p-6 rounded-lg transition-all transform hover:scale-105 overflow-hidden ${
                        selectedOdd === odd ? 'ring-2 ring-blue-400' : ''
                      }`}
                    >
                      <div className="relative z-10">
                        <div className="text-3xl font-bold mb-1">{odd}x</div>
                        <div className="text-xs text-slate-400 mb-2">{oddLabels[odd]}</div>
                        {pred && (
                          <div className="text-sm font-semibold text-blue-400">
                            {pred.confidence}%
                          </div>
                        )}
                      </div>
                      {pred && (
                        <div
                          className={`absolute bottom-0 left-0 h-1 ${oddColors[odd]} transition-all duration-700`}
                          style={{ width: `${pred.confidence}%` }}
                        />
                      )}
                    </button>
                  );
                })}
              </div>
            )}

            {/* Results */}
            {result && (
              <div className="bg-slate-800 rounded-lg p-6 shadow-xl">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-bold">Prediction Result</h3>
                  <button
                    onClick={copyResult}
                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg flex items-center gap-2"
                  >
                    <Copy className="w-4 h-4" />
                    Copy
                  </button>
                </div>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                  <div>
                    <div className="text-sm text-slate-400">Target</div>
                    <div className="text-2xl font-bold text-blue-400">{result.odd}x</div>
                  </div>
                  <div>
                    <div className="text-sm text-slate-400">Confidence</div>
                    <div className="text-2xl font-bold text-green-400">{result.confidence}%</div>
                  </div>
                  <div>
                    <div className="text-sm text-slate-400">Signal Time</div>
                    <div className="text-xl font-bold">{result.targetTime}</div>
                  </div>
                  <div>
                    <div className="text-sm text-slate-400">Entropy</div>
                    <div className="text-lg font-mono">{result.entropy.toFixed(3)}</div>
                  </div>
                  <div>
                    <div className="text-sm text-slate-400">Score</div>
                    <div className="text-lg font-mono">{result.score}</div>
                  </div>
                  <div>
                    <div className="text-sm text-slate-400">Delay</div>
                    <div className="text-lg">{result.delay}s</div>
                  </div>
                </div>
              </div>
            )}

            {/* Countdown */}
            {countdown && (
              <div
                className={`p-4 rounded-lg text-center font-semibold ${
                  countdown.type === 'active'
                    ? 'bg-green-600 animate-pulse'
                    : countdown.type === 'urgent'
                    ? 'bg-red-600'
                    : countdown.type === 'warning'
                    ? 'bg-yellow-600'
                    : 'bg-blue-600'
                }`}
              >
                {countdown.text}
              </div>
            )}
          </div>
        )}

        {activeTab === 'history' && (
          <div className="bg-slate-800 rounded-lg p-6 shadow-xl">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-bold">Prediction History</h3>
              <button
                onClick={() => setHistory([])}
                className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg flex items-center gap-2"
              >
                <Trash2 className="w-4 h-4" />
                Clear
              </button>
            </div>
            <div className="space-y-3">
              {history.length === 0 ? (
                <p className="text-slate-400 text-center py-8">No predictions yet</p>
              ) : (
                history.map(entry => (
                  <div key={entry.id} className="flex items-center justify-between p-4 bg-slate-900 rounded-lg">
                    <div className="flex items-center gap-4">
                      <div className={`w-16 h-16 ${oddColors[entry.odd]} rounded-lg flex items-center justify-center font-bold text-xl`}>
                        {entry.odd}x
                      </div>
                      <div>
                        <div className="font-semibold">{entry.targetTime}</div>
                        <div className="text-sm text-slate-400">
                          Created: {entry.time} • Confidence: {entry.confidence}%
                        </div>
                      </div>
                    </div>
                    <ChevronRight className="w-5 h-5 text-slate-600" />
                  </div>
                ))
              )}
            </div>
          </div>
        )}
      </div>

      {/* Signal Popup */}
      {showSignal && signalData && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50" onClick={() => setShowSignal(false)}>
          <div className="bg-slate-800 rounded-lg p-6 max-w-md w-full shadow-2xl" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-blue-400">Signal Alert</h3>
              <button onClick={() => setShowSignal(false)} className="text-slate-400 hover:text-white">×</button>
            </div>
            <div className="text-center mb-4">
              <div className={`inline-block px-6 py-3 ${oddColors[signalData.odd]} rounded-lg text-3xl font-bold mb-2`}>
                {signalData.odd}x
              </div>
              <div className="text-lg">Target Time: {signalData.targetTime}</div>
            </div>
            <div className="bg-slate-900 rounded-lg p-4 space-y-2 text-sm">
              <div className="flex items-start gap-2">
                <Check className="w-4 h-4 text-green-400 mt-0.5 flex-shrink-0" />
                <span>Enter at specified time</span>
              </div>
              <div className="flex items-start gap-2">
                <Check className="w-4 h-4 text-green-400 mt-0.5 flex-shrink-0" />
                <span>Use auto-cashout at {signalData.odd}x</span>
              </div>
              <div className="flex items-start gap-2">
                <Check className="w-4 h-4 text-green-400 mt-0.5 flex-shrink-0" />
                <span>Maximum 3 rounds per signal</span>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Disclaimer */}
      <div className="fixed bottom-4 right-4 max-w-xs">
        <div className="bg-red-600/20 border border-red-600 rounded-lg p-3 text-xs">
          <AlertCircle className="w-4 h-4 inline mr-1" />
          <strong>Disclaimer:</strong> Predictions are analytical. Gambling involves risk.
        </div>
      </div>
    </div>
  );
};

export default AviatorPredictor;